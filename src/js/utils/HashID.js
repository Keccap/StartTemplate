/**
 * HashID
 */
let instanceHashID = null;

export class HashID {
  constructor() {
    /**
     * The default alphabet is 25 numbers and lowercase letters.
     * Any numbers that look like letters and vice versa are removed:
     * 1 l, 0 o.
     * @type {string}
     */
    this.DEFAULT_ALPHABET = '23456789abcdefghijkmnpqrstuvwxyz';
    /**
     * Governs the length of the ID
     * @type {number}
     */
    this.DEFAULT_ID_LENGTH = 8;
    /**
     * Governs the number of times we should try to find
     * a unique value before giving up.
     * @type {number}
     */
    this.UNIQUE_RETRIES = 9999;
    /**
     * The list of previous ids to avoid
     * @type {Array}
     */
    this.previous = [];

    if (!instanceHashID) {
      instanceHashID = this;
    }

    return instanceHashID;
  }

  /**
   * Returns a randomly-generated friendly ID.
   * Note that the friendly ID is not guaranteed to be
   * unique to any other ID generated by this same method,
   * so it is up to you to check for uniqueness.
   * @returns {string} friendly ID
   */
  generate(params = {}) {
    let alphabet = params.alphabet || this.DEFAULT_ALPHABET;
    let idLength = params.idLength || this.DEFAULT_ID_LENGTH;
    let id = '';

    for (let i = 0; i < idLength; i++) {
      id += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
    }

    return id;
  }

  /**
   * Tries to generate a unique ID that is not defined in the `previous` array.
   * @param {array} previous The list of previous ids to avoid
   * @returns {string} A unique ID, or `null` if one could not be generated
   */
  generateUnique(previous = null) {
    previous = previous || this.previous;
    let retries = 0;
    let id;

    // Try to generate a unique ID, i.e. one that isn't in the previous.
    while (!id && retries < this.UNIQUE_RETRIES) {
      id = this.generate();

      if (previous.indexOf(id) !== -1) {
        id = null;
        retries++;
      }
    }
    this.previous.push(id);

    return id;
  }
}

export default HashID;
